<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3 Chain Labs AI</title>
    <style>
        #chat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 400px;
            border: 1px solid #ccc;
            background: white;
        }
        #chat-messages {
            height: 80%;
            overflow-y: auto;
            padding: 10px;
        }
        #chat-input {
            width: 100%;
            padding: 5px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <header>
        <h1>Web3 Chain Labs AI</h1>
        <p>üöÄ Under development.</p>
    </header>

    <section id="crypto-info">
        <h2>Crypto Updates</h2>
        <p><strong>Prices:</strong> <span id="prices">Loading...</span></p>
        <p><strong>Forecast:</strong> <span id="forecast">Loading...</span></p>
    </section>

    <div id="chat-container">
        <div id="chat-messages"></div>
        <input id="chat-input" type="text" placeholder="Ask me anything..." />
    </div>

    <script>
        const RENDER_URL = "https://web3-aicrypto-bot-free.onrender.com";
        const BINANCE_API_URL = "https://api.binance.com";
        const COINGECKO_API_URL = "https://api.coingecko.com/api/v3";

        async function fetchBinancePrice(symbol) {
            try {
                const response = await fetch(`${BINANCE_API_URL}/api/v3/ticker/price?symbol=${symbol}USDT`);
                if (!response.ok) throw new Error(`Failed to fetch ${symbol}`);
                const data = await response.json();
                return parseFloat(data.price).toFixed(4) + " USDT";
            } catch (error) {
                console.error("Binance Error:", error.message);
                return "N/A";
            }
        }

        async function fetchCoinGeckoPrice(coinId) {
            try {
                const response = await fetch(`${COINGECKO_API_URL}/simple/price?ids=${coinId}&vs_currencies=usd`);
                if (!response.ok) throw new Error(`Failed to fetch ${coinId}`);
                const data = await response.json();
                return parseFloat(data[coinId].usd).toFixed(4) + " USD";
            } catch (error) {
                console.error("CoinGecko Error:", error.message);
                return "N/A";
            }
        }

        async function fetchBinancePrices() {
            try {
                const response = await fetch(`${BINANCE_API_URL}/api/v3/ticker/price?symbols=["BTCUSDT","ETHUSDT","SOLUSDT","BNBUSDT","ADAUSDT","XMRUSDT","DOTUSDT"]`);
                if (!response.ok) throw new Error('Failed to fetch prices');
                const data = await response.json();
                return data.map(item => ({
                    symbol: item.symbol.replace("USDT", ""),
                    price: parseFloat(item.price).toFixed(4) + " USDT"
                }));
            } catch (error) {
                console.error("Binance API Error:", error.message);
                return null;
            }
        }

        async function getCryptoPrice(coinName) {
            const cryptoMap = {
                "–±–∏—Ç–∫–æ–π–Ω": "bitcoin", "bitcoin": "bitcoin", "btc": "bitcoin",
                "–µ—Ç–µ—Ä–∏—É–º": "ethereum", "ethereum": "ethereum", "eth": "ethereum",
                "—Å–æ–ª–∞–Ω–∞": "solana", "sol": "solana",
                "–±–∏–Ω–∞–Ω—Å": "binancecoin", "bnb": "binancecoin",
                "–∫–∞—Ä–¥–∞–Ω–æ": "cardano", "ada": "cardano",
                "–º–æ–Ω–µ—Ä–æ": "monero", "xmr": "monero",
                "–ø–æ–ª–∫–∞–¥–æ—Ç": "polkadot", "dot": "polkadot",
                "—Ä–∏–ø–ø—ä–ª": "ripple", "ripple": "ripple", "xrp": "ripple",
                "–¥–æ–≥–µ–∫–æ–π–Ω": "dogecoin", "dogecoin": "dogecoin", "doge": "dogecoin",
                "—à–∏–±–∞": "shiba-inu", "shiba": "shiba-inu", "shib": "shiba-inu"
            };
            const coinId = cryptoMap[coinName.toLowerCase()] || coinName.toLowerCase();
            const binancePrice = await fetchBinancePrice(coinId.toUpperCase());
            const coingeckoPrice = await fetchCoinGeckoPrice(coinId);
            return { binance: binancePrice, coingecko: coingeckoPrice };
        }

        async function updateCryptoInfo() {
            try {
                const pricesResponse = await fetchBinancePrices();
                const pricesData = pricesResponse ? pricesResponse.map(p => `${p.symbol}: ${p.price}`).join(", ") : "Error fetching prices";
                document.getElementById('prices').textContent = pricesData;

                const forecastResponse = await fetch(`${RENDER_URL}/api/forecast`);
                const forecastData = await forecastResponse.json();
                document.getElementById('forecast').textContent = forecastData.forecast;
            } catch (error) {
                document.getElementById('prices').textContent = 'Error';
                document.getElementById('forecast').textContent = 'Error';
            }
        }
        updateCryptoInfo();
        setInterval(updateCryptoInfo, 300000);

        const messagesDiv = document.getElementById('chat-messages');
        const input = document.getElementById('chat-input');

        input.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter' && input.value.trim()) {
                const userMessage = input.value;
                messagesDiv.innerHTML += `<p><strong>You:</strong> ${userMessage}</p>`;
                input.value = '';

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞ –ø—Ä–æ—Å—Ç–∏ –ø–æ–∑–¥—Ä–∞–≤–∏
                const greetings = ['—Ö–∞–ª–ª–æ', '–∑–¥—Ä–∞–≤–µ–π', 'hello', 'hi', '–∑–¥—Ä–∞—Å—Ç–∏'];
                if (greetings.includes(userMessage.toLowerCase())) {
                    messagesDiv.innerHTML += `<p><strong>Bot:</strong> –ó–¥—Ä–∞–≤–µ–π! –ö–∞–∫ –º–æ–≥–∞ –¥–∞ —Ç–∏ –ø–æ–º–æ–≥–Ω–∞ –¥–Ω–µ—Å?</p>`;
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    return; // –°–ø–∏—Ä–∞–º–µ –ø–æ-–Ω–∞—Ç–∞—Ç—ä—à–Ω–æ—Ç–æ –∏–∑–ø—ä–ª–Ω–µ–Ω–∏–µ
                }

                try {
                    const prices = await fetchBinancePrices();
                    const priceData = prices ? prices.map(p => `${p.symbol}: ${p.price}`).join(", ") : "No current prices from Binance";
                    const btcCoinGecko = await fetchCoinGeckoPrice("bitcoin");
                    const ethCoinGecko = await fetchCoinGeckoPrice("ethereum");
                    const xmrCoinGecko = await fetchCoinGeckoPrice("monero");
                    const dotCoinGecko = await fetchCoinGeckoPrice("polkadot");
                    const coinGeckoData = `BTC: ${btcCoinGecko}, ETH: ${ethCoinGecko}, XMR: ${xmrCoinGecko}, DOT: ${dotCoinGecko}`;

                    let prompt = `Answer the following question in the same language as the question, using these current prices if relevant: Binance: ${priceData}, CoinGecko: ${coinGeckoData}. Question: ${userMessage}`;

                    const priceMatch = userMessage.match(/(—Ü–µ–Ω–∞|price).*?(–Ω–∞|of)\s+([–∞-—è–ê-–Øa-zA-Z]+)/i);
                    if (priceMatch) {
                        const coinName = priceMatch[3];
                        const coinPrices = await getCryptoPrice(coinName);
                        prompt = `Answer the following question in the same language as the question, using these current prices: Binance: ${coinPrices.binance}, CoinGecko: ${coinPrices.coingecko}. For other cryptocurrencies, use: Binance: ${priceData}, CoinGecko: ${coinGeckoData}. Question: ${userMessage}`;
                    }

                    const response = await fetch(`${RENDER_URL}/api/chat?message=${encodeURIComponent(prompt)}`);
                    if (!response.ok) throw new Error('Server not responding');
                    const data = await response.json();
                    messagesDiv.innerHTML += `<p><strong>Bot:</strong> ${data.response}</p>`;
                } catch (error) {
                    messagesDiv.innerHTML += `<p><strong>Bot:</strong> Error: ${error.message}</p>`;
                }
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        });
    </script>
</body>
</html>
